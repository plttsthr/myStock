"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("core-js/modules/es.string.trim.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.split.js");

require("core-js/modules/web.dom-collections.iterator.js");

require("core-js/modules/es.parse-int.js");

var _handleBackspace = _interopRequireDefault(require("./_lib/handleBackspace"));

var _isSeparator = _interopRequireDefault(require("./_lib/isSeparator"));

var _removeSeparators = _interopRequireDefault(require("./filters/removeSeparators"));

var _removeLetters = _interopRequireDefault(require("./filters/removeLetters"));

var _removeNumbers = _interopRequireDefault(require("./filters/removeNumbers"));

var _setDefaultOption = _interopRequireDefault(require("./_lib/setDefaultOption"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const formatString = function formatString(newInput) {
  let format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  (0, _setDefaultOption.default)(options, 'lettersAsSeparators', false);
  (0, _setDefaultOption.default)(options, 'numbersOnly', false);
  (0, _setDefaultOption.default)(options, 'lettersOnly', false);
  (0, _setDefaultOption.default)(options, 'allCaps', false); // Check for conflicting parameters

  checkParameters(options);
  const {
    lettersAsSeparators,
    backspaceAt,
    deleteAt,
    customFormatter,
    numbersOnly,
    lettersOnly,
    allCaps
  } = options; // Handle backspace/delete if necessary

  if (typeof backspaceAt === 'number') {
    newInput = (0, _handleBackspace.default)(newInput, backspaceAt);
  } else if (typeof deleteAt === 'number') {
    newInput = (0, _handleBackspace.default)(newInput, deleteAt, true);
  }

  if (numbersOnly) newInput = (0, _removeLetters.default)(newInput);
  if (lettersOnly) newInput = (0, _removeNumbers.default)(newInput);
  if (allCaps) newInput = newInput.toUpperCase(); // Clean up input and re-start process

  let rawValue = (0, _removeSeparators.default)(newInput, lettersAsSeparators);
  if (rawValue.length === 0) return ''; // Use custom formatter callback if provided

  if (typeof customFormatter === 'function') return customFormatter(rawValue); // Clean up format and initialize separator map

  const formatCleaned = format.trim();
  const formatLength = formatCleaned.length;
  const separatorMap = buildSeparatorsMap(format, lettersAsSeparators);
  const numSeparators = Object.keys(separatorMap).length; // Check for faulty format

  const invalidFormat = checkFormat(formatLength, numSeparators);
  if (invalidFormat) return rawValue; // Trim raw string if it exceeds its max length

  const maxInputLength = formatLength - numSeparators;

  if (rawValue.length > maxInputLength) {
    rawValue = rawValue.substring(0, maxInputLength);
  } // Convert rawValue into an array


  const inputArray = rawValue.split('');

  for (const [idxString, separator] of Object.entries(separatorMap)) {
    const index = parseInt(idxString); // Break loop if index exceeds input length

    if (index > inputArray.length) break; // Insert separator at index

    inputArray.splice(index, 0, separator);
  }

  return inputArray.join('');
};

var _default = formatString; // ********************************************************************
// HELPER FUNCTIONS

/**
 * Check for any conflicting option parameters.
 * 
 * @param {object} options - The options object for formatString
 */

exports.default = _default;

const checkParameters = options => {
  if (options.numbersOnly && options.lettersOnly) {
    throw new Error('One of numbersOnly or lettersOnly must be false.');
  }

  if (options.lettersOnly && options.lettersAsSeparators) {
    throw new Error("lettersOnly and lettersAsSeparators can't both be true.");
  }
};
/**
 * Check for faulty format.
 * 
 * @param {number} formatLength - The length of the format string
 * @param {number} numSeparators - The number of separators in the format string
 * @returns {boolean}
 */


const checkFormat = (formatLength, numSeparators) => {
  let hasErrors = false; // Print error if format is non-empty

  if (formatLength < 1) {
    console.error('String format must be at least one character long.');
    hasErrors = true;
  } // Print error if entire format string is composed of errors


  if (numSeparators === formatLength && numSeparators > 0) {
    console.error('Formatted string cannot consist of only separators.');
    hasErrors = true;
  }

  return hasErrors;
};
/**
 * Determine indices of the format's separator(s).
 * 
 * @param {string} format - The string's format
 * @param {boolean} lettersAsSeparators - Whether letters are to be considered as separators
 * @returns {object}
 */


const buildSeparatorsMap = function buildSeparatorsMap(format) {
  let lettersAsSeparators = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  const separatorMap = {};

  for (let i = 0; i < format.length; i++) {
    const char = format[i];
    if (!(0, _isSeparator.default)(char, lettersAsSeparators)) continue;
    separatorMap[i] = char;
  }

  return separatorMap;
};