{"ast":null,"code":"import _classCallCheck from \"/Users/paulette./Documents/GitHub/MyStockApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/paulette./Documents/GitHub/MyStockApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/paulette./Documents/GitHub/MyStockApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/Users/paulette./Documents/GitHub/MyStockApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/paulette./Documents/GitHub/MyStockApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport { addDomEvent } from '../events/add-dom-event.mjs';\nimport { Feature } from '../motion/features/Feature.mjs';\nimport { AnimationType } from '../render/utils/types.mjs';\nimport { pipe } from '../utils/pipe.mjs';\nvar FocusGesture = /*#__PURE__*/function (_Feature) {\n  _inherits(FocusGesture, _Feature);\n  var _super = _createSuper(FocusGesture);\n  function FocusGesture() {\n    var _this;\n    _classCallCheck(this, FocusGesture);\n    _this = _super.apply(this, arguments);\n    _this.isActive = false;\n    return _this;\n  }\n  _createClass(FocusGesture, [{\n    key: \"onFocus\",\n    value: function onFocus() {\n      var isFocusVisible = false;\n      /**\n       * If this element doesn't match focus-visible then don't\n       * apply whileHover. But, if matches throws that focus-visible\n       * is not a valid selector then in that browser outline styles will be applied\n       * to the element by default and we want to match that behaviour with whileFocus.\n       */\n      try {\n        isFocusVisible = this.node.current.matches(\":focus-visible\");\n      } catch (e) {\n        isFocusVisible = true;\n      }\n      if (!isFocusVisible || !this.node.animationState) return;\n      this.node.animationState.setActive(AnimationType.Focus, true);\n      this.isActive = true;\n    }\n  }, {\n    key: \"onBlur\",\n    value: function onBlur() {\n      if (!this.isActive || !this.node.animationState) return;\n      this.node.animationState.setActive(AnimationType.Focus, false);\n      this.isActive = false;\n    }\n  }, {\n    key: \"mount\",\n    value: function mount() {\n      var _this2 = this;\n      this.unmount = pipe(addDomEvent(this.node.current, \"focus\", function () {\n        return _this2.onFocus();\n      }), addDomEvent(this.node.current, \"blur\", function () {\n        return _this2.onBlur();\n      }));\n    }\n  }, {\n    key: \"unmount\",\n    value: function unmount() {}\n  }]);\n  return FocusGesture;\n}(Feature);\nexport { FocusGesture };","map":null,"metadata":{},"sourceType":"module"}